//ROS typedefs
#include "ros/ros.h"
#include <brics_showcase_industry_interfaces/MoveGripper.h>

/* protected region user include files on begin */
#include <schunk_libm5api/m5apiw32.h>
#include <sstream>
using namespace std;
/* protected region user include files end */

class schunk_gripper_config
{
public:
		std::string dev_string;
		double open_pos;
		double close_pos;
		int baudrate;
		int modul_id;
		double speed;

};

class schunk_gripper_data
{
// autogenerated: don't touch this class
public:
//input data
  
	
//output data
 

};

class schunk_gripper_impl
{
	/* protected region user member variables on begin */
	int m_dev;
	float max_pos;
	float min_pos;
	/* protected region user member variables end */

public:
    schunk_gripper_impl() 
    {
        /* protected region user constructor on begin */
    	max_pos = 0.0;
    	min_pos = 0.0;
		/* protected region user constructor end */
    }
    void configure(schunk_gripper_config config) 
    {
        /* protected region user configure on begin */
    	std::cout << "Configuring\n";
    	ostringstream initStr;
    	initStr << "PCAN" << ":" << config.dev_string << "," << config.baudrate;
    	std::cout << "initstring = " << initStr.str().c_str() << "\n";
    	int ret = 0;
    	ret = PCube_openDevice (&m_dev, initStr.str().c_str());
    	if (ret != 0)
    	{
    	      std::cerr << "Could not open device, m5api error code: "<< ret << "\n";
    	      return;
    	}
    	PCube_resetAll(m_dev);
    	PCube_homeAll(m_dev);
    	int nr_of_modules=PCube_getModuleCount(m_dev);
    	std::cout <<"Nr of modules available: " << nr_of_modules << "\n";
    	if(nr_of_modules <= 0)
    	{
    		std::cerr<<"No modules found."<<"\n";
    	    PCube_closeDevice(m_dev);
    	    return;
    	}
    	unsigned long module_state;
    	for(int i=0;i<nr_of_modules;i++)
    	{
    		PCube_getModuleState(m_dev,i,&module_state);
    	    std::cout<<"State of module "<<i<<": "<<module_state<<"\n";
    	}
    	ret = PCube_getMinPos(m_dev,config.modul_id,&min_pos);
    	if (ret != 0)
    	{
    		std::cerr << "Could not get minimum position for module nr:"<<config.modul_id <<", error: "<< ret << "\n";
    	    PCube_closeDevice(m_dev);
    	    return;
    	}
    	ret = PCube_getMaxPos(m_dev,config.modul_id,&max_pos);
    	if (ret != 0)
    	{
    		std::cerr << "Could not get maximum position for module nr:"<<config.modul_id <<", error: "<< ret << "\n";
    	    PCube_closeDevice(m_dev);
    	    return;
    	}
    	ret = PCube_setMaxVel(m_dev,config.modul_id,config.speed);
    	if (ret != 0)
    	{
    		std::cerr << "Could not set maximum velocity for module nr:"<<config.modul_id <<", error: "<< ret << "\n";
    	    PCube_closeDevice(m_dev);
    	    return;
    	}
		/* protected region user configure end */
    }
    void update(schunk_gripper_data &data, schunk_gripper_config config)
    {
        /* protected region user update on begin */
		/* protected region user update end */
    }

	bool callback_MoveGripper(brics_showcase_industry_interfaces::MoveGripper::Request  &req, brics_showcase_industry_interfaces::MoveGripper::Response &res , schunk_gripper_config config)
	{
		/* protected region user implementation of service callback for MoveGripper on begin */
		if(req.open == 0) //closing gripper
		{
			PCube_haltModule(m_dev,config.modul_id);
			PCube_resetModule(m_dev,config.modul_id);
			if(PCube_moveRamp(m_dev,config.modul_id,min_pos,config.speed,1.0)!=0)
				return false;
			return true;
		}
		if(req.open == 1) //opening gripper
		{
			PCube_haltModule(m_dev,config.modul_id);
			PCube_resetModule(m_dev,config.modul_id);

			if(PCube_moveRamp(m_dev,config.modul_id,max_pos,config.speed,1.0)!=0)
				return false;
			return true;
		}
		/* protected region user implementation of service callback for MoveGripper end */
		return true;
	}
    
    /* protected region user additional functions on begin */
	/* protected region user additional functions end */
    
};
